{% load static %}
<!DOCTYPE html>
<html lang="et">
  <head>
    {% if not DEBUG %}
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-EE45M236XG"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-EE45M236XG');
    </script>
    {% endif %}
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Perekas{% endblock %}</title>
    <!-- Favicon with proper sizes for better transparency support -->
    <link rel="icon" type="image/png" sizes="192x192" href="{% static 'logos/perekas-logo.png' %}">
    <link rel="icon" type="image/png" sizes="32x32" href="{% static 'logos/perekas-logo.png' %}">
    <link rel="icon" type="image/png" sizes="16x16" href="{% static 'logos/perekas-logo.png' %}">
    <link rel="apple-touch-icon" sizes="180x180" href="{% static 'logos/perekas-logo.png' %}">
    <link rel="mask-icon" href="{% static 'logos/perekas-logo.png' %}" color="#8b5cf6">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap"
      rel="stylesheet"
    >
    <link rel="stylesheet" href="{% static 'styles.css' %}">
    <style>
      /* Fallback styles for messages - ensure they always work */
      .messages-container {
        position: fixed !important;
        top: 1.5rem !important;
        left: 50% !important;
        transform: translateX(-50%) !important;
        z-index: 10000 !important;
        display: flex !important;
        flex-direction: column !important;
        gap: 0.75rem !important;
        max-width: 600px !important;
        width: calc(100% - 3rem) !important;
        pointer-events: none !important;
      }
      .message-toast {
        position: relative !important;
        display: flex !important;
        align-items: center !important;
        justify-content: space-between !important;
        gap: 1rem !important;
        padding: 1rem 1.25rem !important;
        border-radius: 1rem !important;
        backdrop-filter: blur(12px) !important;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4) !important;
        border: 1px solid !important;
        pointer-events: auto !important;
        min-width: 300px !important;
      }
      .message-toast-success {
        background: rgba(34, 197, 94, 0.15) !important;
        border-color: rgba(34, 197, 94, 0.4) !important;
        color: #22c55e !important;
      }
      .message-toast-error {
        background: rgba(239, 68, 68, 0.15) !important;
        border-color: rgba(239, 68, 68, 0.4) !important;
        color: #ef4444 !important;
      }
      .message-toast-warning {
        background: rgba(245, 158, 11, 0.15) !important;
        border-color: rgba(245, 158, 11, 0.4) !important;
        color: #f59e0b !important;
      }
      .message-toast-info {
        background: rgba(59, 130, 246, 0.15) !important;
        border-color: rgba(59, 130, 246, 0.4) !important;
        color: #3b82f6 !important;
      }
    </style>
  </head>
  <body>
    <div class="background-glow"></div>
    <div class="app-shell" id="appShell">
      <!-- Mobile Menu Toggle -->
      <button class="mobile-nav-toggle" aria-label="Lülita menüü" onclick="toggleMobileNav()">
        <span></span>
        <span></span>
        <span></span>
      </button>
      
      <!-- Mobile Menu Overlay -->
      <div class="mobile-menu-overlay" id="mobileMenuOverlay" onclick="closeMobileNav()"></div>
      
      <aside class="sidebar" id="sidebar">
        <div class="sidebar-top-section">
          <div class="sidebar-header">
            <div class="sidebar-logo">
              <img src="{% static 'logos/perekas-logo.png' %}" alt="Perekas" style="width: 100%; height: 100%; object-fit: contain; border-radius: inherit; background: transparent;" />
            </div>
            <div>
              <div class="sidebar-brand">Perekas</div>
              <div class="sidebar-tagline">Koos iga päev</div>
            </div>
          </div>

          <div class="sidebar-nav-top">
            {% block sidebar_nav %}
            <nav class="sidebar-nav">
            <a class="nav-link{% block nav_dashboard_active %}{% endblock %}" href="{% url 'a_dashboard:dashboard' %}">
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <path d="M3 12l2-2 3 3 7-7 6 6v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
              </svg>
              <span>Ülevaade</span>
            </a>
            <a class="nav-link{% block nav_tasks_active %}{% endblock %}" href="{% url 'a_tasks:index' %}">
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <path d="M3 5h12"></path>
                <path d="M3 12h12"></path>
                <path d="M3 19h12"></path>
                <path d="M18 9l3 3-3 3"></path>
              </svg>
              <span>Ülesanded</span>
            </a>
            <a class="nav-link{% block nav_rewards_active %}{% endblock %}" href="{% url 'a_rewards:index' %}">
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <path d="M12 2l1.5 4.5H18l-3.75 2.7L15.75 14 12 11.4 8.25 14l1.5-4.8L6 6.5h4.5z"></path>
              </svg>
              <span>Preemiad</span>
            </a>
            {% if has_shopping_list_access %}
              <a class="nav-link{% block nav_shopping_active %}{% endblock %}" href="{% url 'a_shopping:index' %}">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                  <circle cx="9" cy="21" r="1"></circle>
                  <circle cx="20" cy="21" r="1"></circle>
                  <path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path>
                </svg>
                <span>Ostunimekiri</span>
              </a>
            {% endif %}
            </nav>
            {% endblock %}
          </div>
        </div>
        
        <div class="sidebar-nav-bottom-section">
          {% block sidebar_nav_bottom %}
          <nav class="sidebar-nav sidebar-nav-bottom">
          <a class="nav-link nav-link-settings{% block nav_settings_active %}{% endblock %}" href="{% url 'a_account:settings' %}?section=general">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <path d="M12 15.5a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7z"></path>
              <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 1 1-4 0v-.09a1.65 1.65 0 0 0-1-1.51 1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 1 1-2.83-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 1 1 0-4h.09a1.65 1.65 0 0 0 1.51-1 1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 1 1 2.83-2.83l.06.06a1.65 1.65 0 0 0 1.82.33H10a1.65 1.65 0 0 0 1-1.51V3a2 2 0 1 1 4 0v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V10a1.65 1.65 0 0 0 1.51 1H21a2 2 0 1 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
            </svg>
            <span>Seaded</span>
          </a>

          {% if user.role != 'child' and user.is_authenticated %}
            <a class="nav-link{% block nav_family_active %}{% endblock %}" href="{% url 'a_family:index' %}">
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
                <polyline points="9 22 9 12 15 12 15 22"></polyline>
              </svg>
              <span>Perekond</span>
            </a>
          {% endif %}
          </nav>
          <div class="sidebar-footer">
            <div class="sidebar-footer-title">{{user.first_name}} {{user.last_name}} - {{user.points}} pkt</div>
            <form method="post" action="{% url 'account_logout' %}">
              {% csrf_token %}
              <button type="submit" class="sidebar-logout">Logi välja</button>
            </form>
          </div>
          {% endblock %}
        </div>
      </aside>

      {% if messages %}
        <div class="messages-container" id="messagesContainer">
          {% for message in messages %}
            {% with tag=message.tags|default:'info' %}
            <div class="message-toast message-toast-{{ tag }}" role="alert" data-message-tag="{{ tag }}">
              <div class="message-toast-content">
                <span class="message-toast-text">{{ message }}</span>
              </div>
              <button type="button" class="message-toast-dismiss" aria-label="Sulge" onclick="dismissMessage(this)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <line x1="18" y1="6" x2="6" y2="18"></line>
                  <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
              </button>
            </div>
            {% endwith %}
          {% endfor %}
        </div>
      {% endif %}

      <main class="main-content">
        {% block content %}{% endblock %}
      </main>
    </div>
    <script>
      function dismissMessage(button) {
        const message = button.closest('.message-toast');
        message.style.opacity = '0';
        message.style.transform = 'translateY(-10px)';
        setTimeout(() => {
          message.remove();
          // If no messages left, hide container
          const container = document.getElementById('messagesContainer');
          if (container && container.children.length === 0) {
            container.remove();
          }
        }, 200);
      }
      
      // Auto-dismiss messages after 5 seconds
      document.addEventListener('DOMContentLoaded', function() {
        const messages = document.querySelectorAll('.message-toast');
        messages.forEach((message, index) => {
          setTimeout(() => {
            const dismissBtn = message.querySelector('.message-toast-dismiss');
            if (dismissBtn) {
              dismissBtn.click();
            }
          }, 5000 + (index * 200)); // Stagger dismissals slightly
        });
      });
      
      // Mobile navigation toggle
      function toggleMobileNav() {
        const sidebar = document.getElementById('sidebar');
        const overlay = document.getElementById('mobileMenuOverlay');
        const toggle = document.querySelector('.mobile-nav-toggle');
        
        sidebar.classList.toggle('mobile-open');
        overlay.classList.toggle('active');
        toggle.classList.toggle('open');
      }
      
      function closeMobileNav() {
        const sidebar = document.getElementById('sidebar');
        const overlay = document.getElementById('mobileMenuOverlay');
        const toggle = document.querySelector('.mobile-nav-toggle');
        
        sidebar.classList.remove('mobile-open');
        overlay.classList.remove('active');
        toggle.classList.remove('open');
      }
      
      // Close mobile nav when clicking a nav link
      document.addEventListener('DOMContentLoaded', function() {
        const navLinks = document.querySelectorAll('.sidebar-nav .nav-link, .nav-link-settings');
        navLinks.forEach(link => {
          link.addEventListener('click', function() {
            if (window.innerWidth <= 1024) {
              closeMobileNav();
            }
          });
        });

        const sidebar = document.getElementById('sidebar');
        const settingsNav = document.querySelector('.settings-nav');
        const isSettingsPage = settingsNav !== null;
        const comingFromSettings = sessionStorage.getItem('fromSettings');
        const comingFromMainApp = sessionStorage.getItem('fromMainApp');
        const hasAnimatedSettings = sessionStorage.getItem('hasAnimatedSettings') === 'true';

        if (isSettingsPage) {
          // We're on a settings page
          if (!hasAnimatedSettings && comingFromMainApp === 'true') {
            // First time entering settings from main app - animate entire sidebar
            sidebar.classList.add('settings-sidebar-fade-in');
            sessionStorage.setItem('hasAnimatedSettings', 'true');
            sessionStorage.removeItem('fromMainApp');
            
            // Remove animation class after animation completes
            setTimeout(() => {
              sidebar.classList.remove('settings-sidebar-fade-in');
            }, 1000);
          } else if (!hasAnimatedSettings) {
            // First load of settings page (e.g., direct URL) - animate once
            settingsNav.classList.add('initial-load');
            sidebar.classList.add('settings-initial-load');
            sessionStorage.setItem('hasAnimatedSettings', 'true');
            
            // Remove animation class after animation completes
            setTimeout(() => {
              settingsNav.classList.remove('initial-load');
              sidebar.classList.remove('settings-initial-load');
            }, 1000);
          }
          // If hasAnimatedSettings is true, don't animate (user is just switching sections)
        } else {
          // We're on main app page
          if (comingFromSettings === 'true') {
            // Coming from settings - animate entire main sidebar
            sidebar.classList.add('sidebar-fade-in');
            sessionStorage.removeItem('fromSettings');
            sessionStorage.removeItem('hasAnimatedSettings');
            
            // Remove animation class after animation completes
            setTimeout(() => {
              sidebar.classList.remove('sidebar-fade-in');
            }, 1000);
          }
        }
      });

      // Track navigation to/from settings
      document.addEventListener('click', function(e) {
        const link = e.target.closest('a');
        if (!link) return;
        
        const href = link.getAttribute('href') || '';
        const settingsNav = document.querySelector('.settings-nav');
        
        // If clicking "Tagasi" (back) button from settings, mark that we're leaving settings
        if (settingsNav && (href.includes('dashboard') || link.textContent.trim() === 'Tagasi')) {
          sessionStorage.setItem('fromSettings', 'true');
        }
        // If clicking settings link from main app, mark that we're going to settings
        else if (!settingsNav && (href.includes('/setup/settings') || href.includes('settings'))) {
          sessionStorage.setItem('fromMainApp', 'true');
          sessionStorage.removeItem('hasAnimatedSettings'); // Allow animation on first entry
        }
      });

      // Auto-refresh polling - only when needed:
      // Multiple family members might be viewing same page
      (function() {
        // Only poll if user is authenticated
        {% if user.is_authenticated %}
        let lastUpdateTimestamp = null;
        let pollingInterval = null;
        let isPolling = false;
        let shouldPollForUpdates = false;
        let hasMultipleMembers = false;
        const statusCheckUrl = '{% url "a_family:status_check" %}';
        
        // Dynamic polling interval - adjusts based on query performance
        let currentPollingInterval = 10000; // Start at 10 seconds
        const MIN_POLLING_INTERVAL = 10000; // 10 seconds minimum
        const MAX_POLLING_INTERVAL = 30000; // 30 seconds maximum
        const QUERY_TIME_THRESHOLD_SLOW = 50; // ms - if query takes longer, slow down polling
        const QUERY_TIME_THRESHOLD_FAST = 10; // ms - if query is fast, can speed up polling
        
        // Check if we should poll for multi-user updates
        // Only poll if there are multiple family members AND we're on a specific page
        // This ensures users on different pages don't poll each other
        function checkIfUpdatePollingNeeded() {
          // Determine current page
          const path = window.location.pathname;
          let currentPage = '';
          
          if (path.includes('/tasks/') || path.endsWith('/tasks')) {
            currentPage = 'tasks';
          } else if (path.includes('/rewards/') || path.endsWith('/rewards')) {
            currentPage = 'rewards';
          } else if (path.includes('/shopping/') || path.endsWith('/shopping')) {
            currentPage = 'shopping';
          } else if (path.includes('/dashboard/') || path.endsWith('/dashboard') || path === '/') {
            currentPage = 'dashboard';
          }
          
          // Only poll if family has multiple members AND we're on a relevant page
          shouldPollForUpdates = hasMultipleMembers && currentPage !== '';
          return shouldPollForUpdates;
        }
        
        // Get current page for status check
        function getCurrentPage() {
          const path = window.location.pathname;
          if (path.includes('/tasks/') || path.endsWith('/tasks')) {
            return 'tasks';
          } else if (path.includes('/rewards/') || path.endsWith('/rewards')) {
            return 'rewards';
          } else if (path.includes('/shopping/') || path.endsWith('/shopping')) {
            return 'shopping';
          } else if (path.includes('/dashboard/') || path.endsWith('/dashboard') || path === '/') {
            return 'dashboard';
          }
          return '';
        }
        
        function checkStatus() {
          // Don't poll if already polling or if page is hidden
          if (isPolling || document.hidden) {
            return;
          }
          
          // Re-check if we still need to poll
          const needsUpdatePoll = checkIfUpdatePollingNeeded();
          
          // Stop polling if not needed
          if (!needsUpdatePoll) {
            stopPolling();
            return;
          }
          
          isPolling = true;
          
          // Include current page in request
          const currentPage = getCurrentPage();
          const url = statusCheckUrl + (currentPage ? '?page=' + encodeURIComponent(currentPage) : '');
          
          console.log('[Polling] Status check:', { currentPage, url, needsUpdatePoll });
          
          fetch(url, {
            method: 'GET',
            credentials: 'same-origin',
            headers: {
              'X-Requested-With': 'XMLHttpRequest',
            }
          })
          .then(response => {
            if (!response.ok) {
              throw new Error('Network response was not ok');
            }
            return response.json();
          })
          .then(data => {
            // Adjust polling interval based on query performance
            if (data.query_time_ms !== undefined) {
              adjustPollingInterval(data.query_time_ms);
            }
            
            // Update has_multiple_members from API response
            if (data.has_multiple_members !== undefined) {
              hasMultipleMembers = data.has_multiple_members;
            }
            
            // Check for data updates (only if we're polling for it)
            if (needsUpdatePoll && data.last_update) {
              const currentUpdate = data.last_update;
              if (lastUpdateTimestamp !== null && lastUpdateTimestamp !== currentUpdate) {
                // Data has changed - refresh page
                window.location.reload();
                return;
              }
              // Set baseline on first check or update if changed
              if (lastUpdateTimestamp === null || lastUpdateTimestamp !== currentUpdate) {
                lastUpdateTimestamp = currentUpdate;
              }
            } else if (needsUpdatePoll && !data.last_update) {
              // No updates yet - initialize to null if not already set
              if (lastUpdateTimestamp === null) {
                lastUpdateTimestamp = null;
              }
            }
          })
          .catch(error => {
            // Silently fail - don't spam console
            console.debug('Status check failed:', error);
          })
          .finally(() => {
            isPolling = false;
          });
        }
        
        // Initial check to get hasMultipleMembers before starting polling
        function initialStatusCheck() {
          const currentPage = getCurrentPage();
          
          // Only check if we're on a relevant page
          if (!currentPage) {
            return;
          }
          
          const url = statusCheckUrl + (currentPage ? '?page=' + encodeURIComponent(currentPage) : '');
          
          console.log('[Polling] Initial status check:', { currentPage, url, pathname: window.location.pathname });
          
          fetch(url, {
            method: 'GET',
            credentials: 'same-origin',
            headers: {
              'X-Requested-With': 'XMLHttpRequest',
            }
          })
          .then(response => {
            if (!response.ok) {
              throw new Error('Network response was not ok');
            }
            return response.json();
          })
          .then(data => {
            console.log('[Polling] Initial status response:', data);
            
            // Set hasMultipleMembers from first response
            if (data.has_multiple_members !== undefined) {
              hasMultipleMembers = data.has_multiple_members;
            }
            
            // Set baseline timestamp
            if (data.last_update) {
              lastUpdateTimestamp = data.last_update;
            }
            
            // Now start polling if needed
            checkIfUpdatePollingNeeded();
            
            console.log('[Polling] Should poll:', { shouldPollForUpdates, hasMultipleMembers, currentPage });
            
            if (shouldPollForUpdates) {
              startPolling();
            }
          })
          .catch(error => {
            console.error('[Polling] Initial status check failed:', error);
            // Still try to start polling after a delay if on relevant page
            setTimeout(() => {
              const currentPage = getCurrentPage();
              if (currentPage) {
                hasMultipleMembers = true; // Optimistic - will be corrected by API
                checkIfUpdatePollingNeeded();
              }
              if (shouldPollForUpdates) {
                startPolling();
              }
            }, 5000);
          });
        }
        
        // Adjust polling interval based on query performance
        function adjustPollingInterval(queryTimeMs) {
          const previousInterval = currentPollingInterval;
          
          if (queryTimeMs > QUERY_TIME_THRESHOLD_SLOW) {
            // Query is slow - increase polling interval (reduce load)
            currentPollingInterval = Math.min(
              currentPollingInterval + 2000, // Increase by 2 seconds
              MAX_POLLING_INTERVAL
            );
            if (previousInterval !== currentPollingInterval) {
              console.log(`[Polling] Query slow (${queryTimeMs.toFixed(1)}ms), increasing interval to ${currentPollingInterval/1000}s`);
              restartPollingWithNewInterval();
            }
          } else if (queryTimeMs < QUERY_TIME_THRESHOLD_FAST && currentPollingInterval > MIN_POLLING_INTERVAL) {
            // Query is fast - decrease polling interval (more responsive)
            currentPollingInterval = Math.max(
              currentPollingInterval - 1000, // Decrease by 1 second
              MIN_POLLING_INTERVAL
            );
            if (previousInterval !== currentPollingInterval) {
              console.log(`[Polling] Query fast (${queryTimeMs.toFixed(1)}ms), decreasing interval to ${currentPollingInterval/1000}s`);
              restartPollingWithNewInterval();
            }
          }
        }
        
        // Restart polling with new interval
        function restartPollingWithNewInterval() {
          if (pollingInterval) {
            stopPolling();
            startPolling();
          }
        }
        
        // Start polling with dynamic interval
        function startPolling() {
          if (pollingInterval) {
            return; // Already polling
          }
          
          // Poll with current dynamic interval
          pollingInterval = setInterval(() => {
            // Re-check if we still need to poll before each check
            checkIfUpdatePollingNeeded();
            
            if (!shouldPollForUpdates) {
              stopPolling();
              return;
            }
            
            checkStatus();
          }, currentPollingInterval);
        }
        
        // Stop polling when page is hidden
        function stopPolling() {
          if (pollingInterval) {
            clearInterval(pollingInterval);
            pollingInterval = null;
          }
        }
        
        // Start polling when page becomes visible
        document.addEventListener('visibilitychange', function() {
          if (document.hidden) {
            stopPolling();
          } else {
            // Re-check status when page becomes visible
            initialStatusCheck();
          }
        });
        
        // Start initial check on page load if visible
        if (document.visibilityState === 'visible') {
          initialStatusCheck();
        }
        
        // Also check when user comes back to tab (focus event)
        window.addEventListener('focus', function() {
          if (!pollingInterval) {
            initialStatusCheck();
          } else {
            checkStatus();
          }
        });
        {% endif %}
      })();
    </script>
    {% block extra_scripts %}{% endblock %}
  </body>
</html>

